# 秒杀功能集成说明文档

## 概述
本文档基于现有苍穹外卖项目，详细说明秒杀功能的数据库设计和集成方案。设计遵循项目开发规范，确保与现有系统的兼容性。

## 数据库设计说明

### 1. 核心表结构

#### 1.1 秒杀活动表 (seckill_activity)
**作用**：管理秒杀活动的基本信息
- 包含活动名称、图片、时间段等商家配置的信息
- 支持活动状态管理（未开始、进行中、已结束、已取消）
- 遵循现有表的字段设计规范（create_time、update_time、create_user等）

#### 1.2 秒杀商品表 (seckill_goods)
**作用**：管理参与秒杀的商品信息和库存
- 支持菜品和套餐两种商品类型
- **核心库存字段**：
  - `total_stock`：总库存
  - `available_stock`：可用库存
  - `sold_count`：已售数量
  - `version`：乐观锁版本号
- 支持限购数量控制
- 包含秒杀价格和原价对比

#### 1.3 秒杀订单表 (seckill_order)
**作用**：关联现有订单系统，扩展秒杀订单功能
- 通过`order_id`关联现有`orders`表
- 支持支付超时控制
- 记录秒杀商品信息和价格

#### 1.4 用户购买记录表 (seckill_user_record)
**作用**：防止用户重复购买，控制限购
- 唯一索引确保同一用户对同一商品只能购买一次
- 记录用户已购买数量

#### 1.5 库存操作日志表 (seckill_stock_log)
**作用**：追踪所有库存变更操作
- 记录扣减、释放、初始化等操作
- 便于问题排查和数据分析

### 2. 与现有系统的集成方式

#### 2.1 订单系统集成
```
现有订单流程：
orders (订单基本信息) → order_detail (订单详情)

秒杀订单流程：
orders (复用现有) → order_detail (复用现有) → seckill_order (秒杀扩展信息)
```

**集成优势**：
- 秒杀订单可以复用现有的接单、发货、配送、送达等流程
- 商家端可以在同一个订单管理界面查看所有订单
- 无需修改现有订单处理逻辑

#### 2.2 商品系统集成
- 秒杀商品通过`goods_type`和`goods_id`关联现有的`dish`或`setmeal`表
- 保持商品基本信息的一致性
- 只在秒杀期间添加库存管理功能

## 乐观锁防超卖机制

### 核心SQL示例
```sql
-- 扣减库存（乐观锁）
UPDATE seckill_goods 
SET available_stock = available_stock - #{quantity}, 
    sold_count = sold_count + #{quantity},
    version = version + 1,
    update_time = NOW()
WHERE id = #{seckillGoodsId} 
  AND available_stock >= #{quantity} 
  AND version = #{version}
  AND status = 1;
```

### 防超卖流程
1. 查询当前库存和版本号
2. 使用版本号进行乐观锁更新
3. 检查更新影响行数，确认扣减成功
4. 记录库存操作日志

## Sentinel限流集成建议

### 限流策略
1. **接口限流**：对秒杀下单接口进行QPS限制
2. **用户限流**：单用户访问频次限制
3. **商品限流**：单个秒杀商品的并发限制

### 配置示例
```java
// 秒杀下单接口限流
@SentinelResource(value = "seckillOrder", blockHandler = "handleBlock")
public Result createSeckillOrder(SeckillOrderDTO orderDTO) {
    // 秒杀下单逻辑
}
```

## 功能实现建议

### 1. 商家端功能

#### 1.1 秒杀管理页面
- **参考页面**：菜品管理页面 (`addDishtype.vue`)
- **主要功能**：
  - 秒杀活动列表展示（分页查询）
  - 新增/编辑秒杀活动
  - 活动状态管理

#### 1.2 新增秒杀活动页面
**新增字段**：
- 活动名称、图片上传
- 时间段选择器
- 商品选择器（从现有菜品/套餐中选择）
- 库存设置、限购数量设置
- 秒杀价格设置

#### 1.3 订单管理集成
- 在现有订单列表中增加"秒杀订单"标识
- 复用现有的接单、发货、配送等功能

### 2. 用户端功能

#### 2.1 秒杀横幅展示
- **位置**：首页顶部滚动横幅
- **数据源**：查询进行中的秒杀活动
- **跳转**：点击跳转到秒杀商品详情页

#### 2.2 秒杀商品详情页
- **参考页面**：现有商品详情页
- **特殊元素**：
  - 倒计时组件
  - 库存显示
  - 限购提示
  - 秒杀价格突出显示

#### 2.3 秒杀下单流程
```
选择商品 → 立即购买 → 生成订单 → 限时支付 → 支付成功/失败处理
```

#### 2.4 个人中心集成
- 在订单列表中增加"秒杀订单"筛选
- 复用现有订单详情、取消等功能

### 3. 后端实现要点

#### 3.1 Controller层
```java
// 管理端
@RestController
@RequestMapping("/admin/seckill")
@Api(tags = "秒杀管理相关接口")
@Slf4j
public class SeckillController {
    // 参考现有Controller的注解和结构
}

// 用户端
@RestController("userSeckillController")
@RequestMapping("/user/seckill")
@Api(tags = "用户端秒杀相关接口")
@Slf4j
public class SeckillController {
    // 参考现有用户端Controller
}
```

#### 3.2 Service层设计
- `SeckillActivityService`：秒杀活动管理
- `SeckillGoodsService`：秒杀商品管理
- `SeckillOrderService`：秒杀订单处理

#### 3.3 关键业务逻辑
1. **库存扣减**：使用乐观锁确保不超卖
2. **订单生成**：集成现有订单生成流程
3. **支付超时处理**：定时任务释放库存
4. **限购控制**：检查用户购买记录

## 数据库索引优化

### 关键索引
```sql
-- 秒杀商品表
INDEX `idx_activity_id`(`activity_id`)          -- 按活动查询
INDEX `idx_status`(`status`)                    -- 按状态查询
UNIQUE INDEX `idx_activity_goods`(`activity_id`, `goods_type`, `goods_id`) -- 防重复

-- 秒杀订单表
INDEX `idx_pay_expire_time`(`pay_expire_time`)  -- 支付超时查询
INDEX `idx_user_id`(`user_id`)                  -- 用户订单查询

-- 用户购买记录表
UNIQUE INDEX `idx_unique_record`(`activity_id`, `seckill_goods_id`, `user_id`) -- 防重复购买
```

## 缓存策略建议

### Redis缓存设计
1. **活动缓存**：`seckill:activity:{activityId}`
2. **库存缓存**：`seckill:stock:{goodsId}`
3. **用户限购缓存**：`seckill:user:{userId}:{goodsId}`

### 缓存更新策略
- 采用缓存与数据库双写模式
- 关键操作后及时更新缓存
- 设置合理的过期时间

## 部署注意事项

### 1. 数据库配置
- 确保UTF-8编码设置正确
- 合理设置连接池大小
- 启用慢查询日志监控

### 2. 应用配置
- 配置Sentinel限流规则
- 设置Redis缓存参数
- 配置定时任务（处理超时订单）

### 3. 监控告警
- 监控库存扣减操作
- 监控订单支付超时率
- 监控接口响应时间

## 测试建议

### 1. 功能测试
- 正常秒杀流程测试
- 库存不足场景测试
- 支付超时场景测试
- 限购功能测试

### 2. 性能测试
- 高并发下单测试
- 库存扣减压力测试
- 数据库连接池测试

### 3. 安全测试
- 防刷单测试
- 接口安全测试
- 数据一致性测试

---

**注意事项**：
1. 严格遵循项目开发规范文档中的编码规范
2. 所有涉及中文字符的代码必须使用UTF-8编码
3. 新增接口需要添加完整的Swagger文档注解
4. 关键操作必须记录详细日志
5. 数据库操作必须考虑事务一致性

本文档将随开发进展持续更新完善。

